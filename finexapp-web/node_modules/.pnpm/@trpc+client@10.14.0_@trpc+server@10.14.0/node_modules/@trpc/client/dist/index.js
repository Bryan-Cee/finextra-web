'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var observable = require('@trpc/server/observable');
var transformResult = require('./transformResult-e7a1e69e.js');
var links_splitLink = require('./splitLink-f29e84be.js');
var shared = require('@trpc/server/shared');
var httpUtils = require('./httpUtils-b67e2601.js');
var links_httpBatchLink = require('./links/httpBatchLink.js');
var links_httpLink = require('./links/httpLink.js');
var links_loggerLink = require('./links/loggerLink.js');
var links_wsLink = require('./links/wsLink.js');

class TRPCUntypedClient {
    $request({ type , input , path , context ={}  }) {
        const chain$ = links_splitLink.createChain({
            links: this.links,
            op: {
                id: ++this.requestId,
                type,
                path,
                input,
                context
            }
        });
        return chain$.pipe(observable.share());
    }
    requestAsPromise(opts) {
        const req$ = this.$request(opts);
        const { promise , abort  } = observable.observableToPromise(req$);
        const abortablePromise = new Promise((resolve, reject)=>{
            opts.signal?.addEventListener('abort', abort);
            promise.then((envelope)=>{
                resolve(envelope.result.data);
            }).catch((err)=>{
                reject(transformResult.TRPCClientError.from(err));
            });
        });
        return abortablePromise;
    }
    query(path, input, opts) {
        return this.requestAsPromise({
            type: 'query',
            path,
            input,
            context: opts?.context,
            signal: opts?.signal
        });
    }
    mutation(path, input, opts) {
        return this.requestAsPromise({
            type: 'mutation',
            path,
            input,
            context: opts?.context,
            signal: opts?.signal
        });
    }
    subscription(path, input, opts) {
        const observable$ = this.$request({
            type: 'subscription',
            path,
            input,
            context: opts?.context
        });
        return observable$.subscribe({
            next (envelope) {
                if (envelope.result.type === 'started') {
                    opts.onStarted?.();
                } else if (envelope.result.type === 'stopped') {
                    opts.onStopped?.();
                } else {
                    opts.onData?.(envelope.result.data);
                }
            },
            error (err) {
                opts.onError?.(err);
            },
            complete () {
                opts.onComplete?.();
            }
        });
    }
    constructor(opts){
        this.requestId = 0;
        function getTransformer() {
            const transformer = opts.transformer;
            if (!transformer) return {
                serialize: (data)=>data,
                deserialize: (data)=>data
            };
            if ('input' in transformer) return {
                serialize: transformer.input.serialize,
                deserialize: transformer.output.deserialize
            };
            return transformer;
        }
        this.runtime = {
            transformer: getTransformer()
        };
        // Initialize the links
        this.links = opts.links.map((link)=>link(this.runtime));
    }
}

function createTRPCUntypedClient(opts) {
    const client = new TRPCUntypedClient(opts);
    return client;
}

/**
 * @deprecated use `createTRPCProxyClient` instead
 */ function createTRPCClient(opts) {
    const client = new TRPCUntypedClient(opts);
    return client;
}

const clientCallTypeMap = {
    query: 'query',
    mutate: 'mutation',
    subscribe: 'subscription'
};
/**
 * @deprecated use `createTRPCProxyClient` instead
 * @internal
 */ function createTRPCClientProxy(client) {
    return shared.createFlatProxy((key)=>{
        if (client.hasOwnProperty(key)) {
            return client[key];
        }
        return shared.createRecursiveProxy(({ path , args  })=>{
            const pathCopy = [
                key,
                ...path
            ];
            const clientCallType = pathCopy.pop();
            const procedureType = clientCallTypeMap[clientCallType];
            const fullPath = pathCopy.join('.');
            return client[procedureType](fullPath, ...args);
        });
    });
}
function createTRPCProxyClient(opts) {
    const client = new TRPCUntypedClient(opts);
    const proxy = createTRPCClientProxy(client);
    return proxy;
}

exports.TRPCClientError = transformResult.TRPCClientError;
exports.splitLink = links_splitLink.splitLink;
exports.getFetch = httpUtils.getFetch;
exports.httpBatchLink = links_httpBatchLink.httpBatchLink;
exports.httpLink = links_httpLink.httpLink;
exports.loggerLink = links_loggerLink.loggerLink;
exports.createWSClient = links_wsLink.createWSClient;
exports.wsLink = links_wsLink.wsLink;
exports.createTRPCClient = createTRPCClient;
exports.createTRPCClientProxy = createTRPCClientProxy;
exports.createTRPCProxyClient = createTRPCProxyClient;
exports.createTRPCUntypedClient = createTRPCUntypedClient;
